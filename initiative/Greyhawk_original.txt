// --------------------------------------
// SWITCHES

// Die sides
const ACTION_DIE_SIDES = {
  ranged_attack: "1d4",
  movement: "1d6",
  swap_gear: "1d6",
  other_action: "1d6",
  melee_attack: "1d8",
  spell: "1d10"
};

const REVISED_ATTACK = false;
const REVISED_SPELL = false;

// Only used if REVISED_ATTACK is true
// The value must be a valid die roll command.
// Value will replace ranged_attack or melee_attack die rolls.
// add selected to the <option> bracket if you want a different default value. (or reorganize)
const HTML_ATTACK_DIE_OPTIONS = 
`
<option value="1d4">1d4</option>
<option value="1d6">1d6</option>
<option value="1d8">1d8</option>
<option value="1d10">1d10</option>
<option value="1d12">1d12</option>
<option value="2d4">2d4</option>
<option value="2d6">2d6</option>
<option value="2d8">2d8</option>
<option value="2d10">2d10</option>  
<option value="2d12">2d12</option>  
<option value="1">1</option>
`;

// Only used if REVISED_SPELL is true
// The value must be a valid die roll command.
// Value will be added to the ACTION_DIE_SIDES.spell die roll (e.g., 1d10 + 5 for a fifth level spell)

const HTML_SPELL_DIE_OPTIONS =
`
<option value="0">Cantrip</option>
<option value="1">1</option>
<option value="2">2</option>
<option value="3">3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>  
<option value="9">9</option>  
`;



// --------------------------------------


// --------------------------------------
// BASIC 	LOCALIZATION SUPPORT
// Set names and error messages as constants for easier translation
// Thanks https://github.com/foundry-vtt-community/macros/blob/f07330b99ec2bde5818600410528ed452272a956/5e/sneak_attack.js
const errorNoCombatants = 'No combatants found in the combat tracker.';
const errorNoCombatantsOwned = 'No owned combatants found in the combat tracker.';
const confirmButton = 'Confirm';
const cancelButton = 'Cancel';
const titleLabel = 'Greyhawk Initiative';

const allLabel = "All";
const PCsLabel = "PCs";
const NPCsLabel = "Creatures / NPCs";
const creatureNamesLabel = "Creature Names";
const creatureTypesLabel = "Creature Types";

const selectCombatantsHeaderLabel = "Select Combatants";
const selectCombatantsParagraph = 
`Select one or more of the following to set their initiative for this turn.
 <br><em> Selecting more than one will set the same actions for all selected.</em>
`;

const selectActionsParagraph = "Please select one or more actions for:";
const selectActionsBonusParagraph = "Initiative bonus/penalty steps largest die down/up, respectively.";
const selectActionsAdvDisParagraph = "Advantage/disadvantage causes the largest die to be rolled with disadvantage/advantage, respectively.";
const selectActionsMultipleParagraph = 
`
<em>
<b>Multiple Actions.</b> 
If an effect grants you	an additional action without the use of a bonus action, 
you roll an initiative	die	for	only one of	your actions. 
Use the largest die that corresponds to any one of the actions you plan to take.
</em>  
`;

// labels for the dialog
const actionLabel = "Action";
const bonusActionLabel = "Bonus Action";
const noneLabel = "None";
const rangedAttackLabel = `Ranged attack (${ACTION_DIE_SIDES.ranged_attack})`;
const movementLabel = `Movement (${ACTION_DIE_SIDES.movement})`;
const swapGearLabel = `Swap Gear (${ACTION_DIE_SIDES.swap_gear})`;
const otherActionLabel = `Other Action (${ACTION_DIE_SIDES.other_action})`;
const meleeAttackLabel = `Melee attack (${ACTION_DIE_SIDES.melee_attack})`;
const castSpellLabel = `Cast Spell (${ACTION_DIE_SIDES.spell})`;
const otherLabel = "Other";
const initiativeBonusLabel = "Initiative Bonus";
const initiativePenaltyLabel = "Initiative Penalty";
const surpriseLabel = "Surprise";
const normalLabel = "Normal";
const advantageLabel = "Advantage";
const disadvantageLabel = "Disadvantage";

// labels for the chat message
const bonusChatLabel = "Bonus"
const rangedAttackChatLabel = `Ranged Attack (${ACTION_DIE_SIDES.ranged_attack})`;
const meleeAttackChatLabel = `Melee Attack (${ACTION_DIE_SIDES.melee_attack})`;
const movementChatLabel = `Movement (${ACTION_DIE_SIDES.movement})`;
const swapGearChatLabel = `Swap Gear (${ACTION_DIE_SIDES.swap_gear})`;
const otherActionChatLabel = `Other Action (${ACTION_DIE_SIDES.other_action})`;
const castSpellChatLabel = `Cast Spell (${ACTION_DIE_SIDES.spell})`;
const otherChatLabel = `Other`;
const surpriseChatLabel = `Surprise`;
const initiativeBonusChatLabel = `Initiative Bonus`;
const initiativePenaltyChatLabel = `Initiative Penalty`;
const advantageChatLabel = `Advantage (lowest roll for largest die)`;
const disadvantageChatLabel = `Disadvantage (highest roll for largest die)`;

// --------------------------------------


// --------------------------------------
// FUNCTIONS: SELECTING COMBATANTS
// --------------------------------------

/**
 * Compares combat token list to the currently selected actors.
 * @combatants Array of combatants.
 * @return An array of combatants. Could be empty.
 */
function filterSelectedCombatants(combatants) {
  //console.log("filterSelectedCombatants");
  const actors = canvas.tokens.controlled.map(({ actor }) => actor);
  let combatantsSelected = [];
  let actor_ids = [];
  if(actors.length < 1) {
    return combatantsSelected;
  }
  
  actors.forEach( a => actor_ids.push(a.data._id));
  //console.log(actor_ids);
  combatantsSelected = combatants.filter(c => actor_ids.includes(c.actor.data._id));
  
	return combatantsSelected;
}

/**
 * Partition combatants into NPC vs Player combatants.
 * @combatants. Array of combatants.
 * @return A structure of { npcCombatants, playerCombatants }.
 */
function partitionCombatants(combatants) {
  let playerCombatants = [];
	let npcCombatants = [];
	combatants.forEach( function(c) {
		if(c.players.length > 0) {
			playerCombatants.push(c);
		} else {
			npcCombatants.push(c);
		}
	});
	
	return { playerCombatants, npcCombatants };
}



// ----------------------------------------------
// Combatant Selection Dialog components
// ----------------------------------------------

/**
 * Create html necessary to display PCs and NPCs.
 * If the NPCs have different groups or names, add those as group selection options.
 * Skip displaying PCs, NPCs, or groups if none are available.
 */
function constructCombatantSelectionHTML(combatants) {
  //console.log(combatants.length + " combatants to partition.");
  const { playerCombatants, npcCombatants } = partitionCombatants(combatants);
  //console.log(playerCombatants.length + " PCs and " + npcCombatants.length + " NPCs.");

  // simplify to names needed
  
  // testing version
  //const PCs = playerCombatants.map(c => ({ id:c.id, name:c.name }));
  //const NPCs = npcCombatants.map(c => ({ id:c.id, name:c.name, groupname:c.groupname, grouptype:c.grouptype}));

  // actual version
  const PCs = playerCombatants.map(c => ({ id:c._id, name:c.name }));
  const NPCs = npcCombatants.map(c => ({ id:c._id, name:c.name, groupname:c.actor.data.token.name, grouptype:c.actor.data.data.details.type}));

  let group_names = [];
  let group_types = [];
  
  const include_pcs = PCs.length > 0;
  const include_npcs = NPCs.length > 0;
  
  // create the jquery script elements
  if(NPCs.length > 2) {
    // need the distinct groupings
    group_names = [...new Set(NPCs.map(a => a.groupname))];
    group_types = [...new Set(NPCs.map(a => a.grouptype))];
    
    if(group_names.length < 2) {
      group_names = [];
    }
    
    if(group_types.length < 2) {
      group_names = [];
    }
  }
  
  //console.log("Group names: " + group_names);
  //console.log("Group types: " + group_types);  
  
  const script_html = constructSelectionScript(include_pcs, include_npcs, group_types, group_names);
  
  // create the main html code
  
  // PCs  
  let pc_block_html = "";
  if(include_pcs) {
    let pc_selection_arr = [];
    PCs.forEach(a => pc_selection_arr.push(constructCombatantSelection(a.id, a.name, "PCs")));
    const pc_selection_html = pc_selection_arr.join(" <br> ");
    
		pc_block_html = 
		`
		${combatant_selection_pcs_header}
		${pc_selection_html}
		<br><br>
		`;
	}  
	
	// NPCs, including group selectors if applicable
	// Don't bother with group selectors unless we have at least two distinct groups
	let npc_block_html = "";
	let npc_group_type_block_html = "";
	let npc_group_name_block_html = "";
	if(include_npcs) {
	  let npc_selection_arr = [];
	  NPCs.forEach(a => npc_selection_arr.push(constructCombatantSelection(a.id, a.name, "Creatures", a.grouptype, a.groupname)));
	  const npc_selection_html = npc_selection_arr.join(" <br> ");
	   
	  npc_block_html = 
	  `
	  ${combatant_selection_npcs_header}
		${npc_selection_html}
		<br><br>
	  `
	  if(group_names.length > 1) {
	    let group_name_selection_arr = [];
			group_names.forEach(n => group_name_selection_arr.push(constructGroupingSelection(n, "Name")));
      const group_name_selection_html = group_name_selection_arr.join(" <br> ");
      
      npc_group_name_block_html =
      `
      ${combatant_selection_group_name_header}
			${group_name_selection_html}
			<br><br>
      `;
	  }
	  
	  if(group_types.length > 1) {
	    let group_type_selection_arr = [];
			group_types.forEach(n => group_type_selection_arr.push(constructGroupingSelection(n, "Type")));
      const group_type_selection_html = group_type_selection_arr.join(" <br> ");
      
      npc_group_type_block_html =
      `
      ${combatant_selection_group_type_header}
			${group_type_selection_html}
			<br><br>
      `;
	  }
	}
	
  // set up a two-column body
  // specific PC and NPC selection in left column.
  // Groupings for NPCs in right column
  const html =  
  `
  ${combatant_selection_header_script}
  ${combatant_selection_header_style}
  <body>
    ${combatant_selection_intro}
		<form>
      ${combatant_selection_all}
      <br><br>
			<div class="row">
				<div class="column">
				
				${pc_block_html}
				${npc_block_html}
				
				</div>
  
				<div class="column">
				
				${npc_group_type_block_html}
				${npc_group_name_block_html}
  
				</div>
			</div>
		</form>
  </body>
  ${script_html} 
  `;
  //console.log(html); 

  return html;
}


const combatant_selection_header_script = 
`
<script src="https://code.jquery.com/jquery-3.4.1.js"   
         integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU="   
         crossorigin="anonymous"> </script>
`;

const combatant_selection_header_style =
`
<style>
  .row {
    display: flex;
  }

  .column {
    flex: 50%;
  }
</style>
`;

const combatant_selection_all = 
`
<input type="checkbox" id="All" class="AllSelection"/>
<label for="All"><strong> ${allLabel} </strong></label>  
  
&nbsp &nbsp <input type="reset" id="resetButton" class="resetButton">
`;

const combatant_selection_intro = 
`
<p>
  <h3> ${selectCombatantsHeaderLabel}</h3>
  ${selectCombatantsParagraph}
  <br>
</p>
`;

const combatant_selection_pcs_header = 
`
<input type="checkbox" id="PCs" class="GroupSelection"/>
<label for="PCs"><strong> ${PCsLabel} </strong></label>
<hr width=100 align="left">
`;

const combatant_selection_npcs_header = 
`
<input type="checkbox" id="Creatures" class="GroupSelection"/>
<label for="Creatures"><strong> ${NPCsLabel} </strong></label>
<hr width=100 align="left">
`;

// to line up the horizontal correctly, keep the checkbox but make invisible
// checkbox for all creature types is redundant, and causes problems with active updating.
const combatant_selection_group_name_header = 
`
<input type="checkbox" id="CreatureNames" class="GroupSelection" style="visibility:hidden"/>
<label for="CreatureNames"><strong> ${creatureNamesLabel} </strong></label>
<hr width=150 align="left">
`;

const combatant_selection_group_type_header = 
`
<input type="checkbox" id="CreatureTypes" class="GroupSelection" style="visibility:hidden"/>
<label for="CreatureTypes"><strong> ${creatureTypesLabel} </strong></label>
<hr width=150 align="left">
`;


/**
 * Create html block for selecting a combatant.
 * @combatantID Combat tracker string id for the combatant.
 * @combatantName Name for the combatant.
 * @combatantGroup PCs or Creatures.
 * @data_type Does the combatant belong to a Type group (e.g., humanoid, undead)?
 * @data_name Does the combatant belong to a Name group (e.g., skeleton to combine Skeleton1, Skeleton2, etc.)
 * @return html block
 */
function constructCombatantSelection(combatantID, combatantName, combatantGroup = "PCs", data_type = "", data_name = "") {
  if("" != data_type) {
    data_type = ` data-type="${data_type}"`
  }
  
  if("" != data_name) {
    data_name = ` data-name="${data_name}"`
  }

  const html =
  `<input type="checkbox" id="${combatantID}" class="${combatantGroup}Selection"${data_type}${data_name}/>
  <label for="${combatantID}">${combatantName}</label> 
  `;
  return html;
}

/**
 * Create html block for selecting a group of combatants.
 * @label Group label (e.g. undead, humanoid, skeleton)
 * @type Name or Type
 * @return html block.
 */
function constructGroupingSelection(label, type = "Name") {
  const html = 
  `
  <input type="checkbox" id="${type}${label}" class="${type}Selection"/>
  <label for="${type}${label}">${label}</label>
  `;
  
  return html;
}

/**
 * Create the jQuery necessary to check and uncheck by group or all.
 * User can select "All" to select all combatants.
 * Select a category name (e.g. PCs) to select all in that category.
 * Can select group types or names for NPCs.
 * @includePCs true if the script should include PC selection code.
 * @includeCreatures true if the script should include NPC/Creature selection code.
 * @groupTypes String array of group types.
 * @groupNames String array of group names.
 * @return script html block
 */
function constructSelectionScript(includePCs, includeCreatures, groupTypes, groupNames) {
  let pc_js = "";
  let pc_check_js = "";
  let pc_uncheck_js = "";
  
  let creature_js = "";
  let creature_check_js = "";
  let creature_uncheck_js = "";
  
  var group_names_js = "";
  let group_names_check_js = "";
  let group_names_uncheck_js = "";
  
  var group_types_js = "";
  let group_types_check_js = "";
  let group_types_uncheck_js = "";
  
  let includeGroupTypes = groupTypes.length > 0;
  let includeGroupNames = groupNames.length > 0;
   
  if(includePCs) {
    pc_js = 
    `  
    $('#PCs').change( function() {
    //console.log("PCs");
    if($(this).is(':checked')) {
      //console.log("\tchecked");
      $('.PCsSelection').prop('checked', true);
      
    } else {
      //console.log("\tunchecked");
      $('.PCsSelection').prop('checked', false);
    }
    });
    
    `;
    pc_check_js = `$('#PCs,.PCsSelection').prop('checked', true);`;
    pc_uncheck_js = `$('#PCs,.PCsSelection').prop('checked', false);`;
  }  
  
  if(includeGroupTypes) {
    group_types_check_js = `$('.TypeSelection').prop('checked', true);`;
    group_types_uncheck_js = `$('.TypeSelection').prop('checked', false);`;
    
    groupTypes.forEach( function(g) {
      group_types_js = group_types_js + 
      `
			$('#Type${g}').change( function() {
			//console.log("Type${g}");
			if($(this).is(':checked')) {
				//console.log("\tchecked");
				$('*[data-type="${g}"]').prop('checked', true);
			
			} else {
				//console.log("\tunchecked");
				$('*[data-type="${g}"]').prop('checked', false);
				$('#Creatures').prop('checked', false);
			}
			});
      `;
    });
  }
  
  if(includeGroupNames) {
    group_names_check_js = `$('.NameSelection').prop('checked', true);`;
    group_names_uncheck_js = `$('.NameSelection').prop('checked', false);`;
    
		groupNames.forEach( function(g) {
      group_names_js = group_names_js + 
      `
			$('#Name${g}').change( function() {
			//console.log("Name${g}");
			if($(this).is(':checked')) {
				//console.log("\tchecked");
				$('*[data-name="${g}"]').prop('checked', true);
			
			} else {
				//console.log("\tunchecked");
				$('*[data-name="${g}"]').prop('checked', false);
				$('#Creatures').prop('checked', false);
			}
			});
      `;
    });
  }
  
  if(includeCreatures) {
    creature_check_js = `$('#Creatures, .CreaturesSelection').prop('checked', true);`;
    creature_uncheck_js = `$('#Creatures, .CreaturesSelection').prop('checked', false);`;
    creature_js =
    `
    $('#Creatures').change( function() {
			//console.log("Creatures");
			if($(this).is(':checked')) {
				//console.log("\tchecked");
				$('.CreaturesSelection').prop('checked', true);
			  ${group_types_check_js}
				${group_names_check_js}
			
			} else {
				//console.log("\tunchecked");
				$('.CreaturesSelection').prop('checked', false);
				${group_types_uncheck_js}
				${group_names_uncheck_js}
			}
    });
    `;
  }
  
  const all_js = 
  `
  $('#All').change( function() {
    //console.log("All");
    if($(this).is(':checked')) {
      //console.log("\tchecked");
      $('#PCs,.PCsSelection').prop('checked', true);
      ${creature_check_js}
      ${group_types_check_js}
      ${group_names_check_js}
    } else {
      //console.log("\tunchecked");
      $('#PCs,.PCsSelection').prop('checked', false);
      ${creature_uncheck_js}
      ${group_types_uncheck_js}
      ${group_names_uncheck_js}     
    }
  });
  `;

	const html = 
	`
	 <script>
	   ${all_js}
	   ${pc_js}
	   ${creature_js}
	   ${group_names_js}
	   ${group_types_js}	   
	 </script>
	`;
  return html;
}


// Code for testing creature selection
/*
var html = constructSelectionScript(true, // includePCs
	                                  true, // includeCreatures
	                                  ["undead", "humanoid", "monstrosity"], 
	                                  ["skeleton", "goblin"]);


console.log(html);
*/

/*

const PCs = [{ id:"1A1", name:"PC1",  players:[1,2,3]}, 
             { id:"2B2", name: "PC2", players:[1,2,3]}];
             
const NPCs = [{ id:"3C3", name:"Bad Skeleton",  grouptype:"undead",      groupname:"Skeleton", players:[]},
              { id:"4C4", name:"Good Skeleton", grouptype:"undead",      groupname:"Skeleton", players:[]},
              { id:"5C5", name:"Big Dragon",    grouptype:"monstrosity", groupname:"Dragon",   players:[]}];
//console.log(PCs.concat(NPCs));
//const NPCmapping = NPCs.map(c => ({ id:c.id, name:c.name }));
//console.log(NPCmapping);
//const combatants = PCs.concat(NPCs);
//const { playerCombatants, npcCombatants } = partitionCombatants(combatants);

//console.log(combatants[0].players.length)
//console.log(playerCombatants);
//console.log(npcCombatants);

const html = constructCombatantSelectionHTML(PCs.concat(NPCs));

console.log(html);
*/

/**
 * Convert dialog to a promise to allow use with await/async.
 * @content HTML content for the dialog.
 * @return Promise for the html content of the dialog
 * Will return "Cancel" or "Close" if those are selected.
 */
function dialogPromise(content) {
  return new Promise((resolve, reject) => {
    dialogCallback(content, (html) => resolve(html)); 
  });
}

/**
 * Create new dialog with a callback function that can be used for dialogPromise.
 * @content HTML content for the dialog.
 * @callbackFn Allows conversion of the callback to a promise using dialogPromise.
 * @return rendered dialog.
 */
function dialogCallback(content, callbackFn) {
	let d = new Dialog({
		title: titleLabel,
		content: content,
		buttons: {
			one: {
				icon: '<i class="fas fa-check"></i>',
				label: confirmButton,
				callback: (html) => callbackFn(html)
			},
			two: {
				icon: '<i class="fas fa-times"></i>',
				label: cancelButton,
				callback: () => callbackFn("Cancel")
			}
			},
		default: "two",
		close: () => callbackFn("Close")
	});
	d.render(true);
}

/**
 * Pull id from array of PCs and NPCs.
 * @PCSelection Array of PC combatants.
 * @CreatureSelection Array of NPC combatants.
 * @return Array of string ids.
 */
function getSelectionIDs(PCSelection, CreatureSelection) {
  //console.log(PCSelection.length + " PC selection objects.");
  //console.log(CreatureSelection.length + " NPC selection objects.");
  
  let ids = [];
  
  
  PCSelection.each( function(index, element) {
    //console.log("Value: " + element.value); // on
    //console.log("Text: " + element.text); // undefined
    //console.log("Id: " + element.id); // string of letters, numbers
    //console.log("Checked: " + element.checked); // true or false
  
    if(element.checked) {
      ids.push(element.id);
    }
  });

  CreatureSelection.each( function(index, element) {
    //console.log("Value: " + element.value); // on
    //console.log("Text: " + element.text); // undefined
    //console.log("Id: " + element.id); // string of letters, numbers
    //console.log("Checked: " + element.checked); // true or false
  
    if(element.checked) {
      ids.push(element.id);
    }
  });
  
  //console.log(ids.length + " ids checked: " + ids);

  return(ids);
}

// --------------------------------------
// FUNCTIONS FOR SELECTING ACTIONS
// --------------------------------------

/**
 * Combine an array of strings.
 * Create a comma-delimited list of unique strings, with number of repeats indicated.
 * For example: Skeleton (x3), Bear (x2), PC
 * @names Array of string names.
 * @return a single combined string.
 */
function combineElementsToSummaryString(names) {
  // testing
  //const names = ["Skeleton", "Skeleton", "Skeleton", "Bear", "PC", "Bear"];

	let counts = {};
	for (let i = 0; i < names.length; i++) {
    counts[names[i]] = 1 + (counts[names[i]] || 0);
	}
	//console.log(counts);
	//console.log(Object.keys(counts));
	//console.log(Object.values(counts));

	const keys = Object.keys(counts);
	const values = Object.values(counts);

	let names_string = [];
	for(let i = 0; i < keys.length; i++) {
		const c = values[i];
		let str = keys[i];
	
		if(c > 1) {
			str += " (x" + c + ")";    
		}
		names_string.push(str);
	}
	
	const joined_str = names_string.join(", ");
	//console.log(names_string);
	//console.log(joined_str);
	return joined_str;
}

/**
 * Create the html code to display choices for selecting Greyhawk Initiative actions.
 * Checkboxes for actions; radio buttons for bonus actions; initiative bonus/penalty;
 * advantage/disadvantage; other (die command as string)
 * @names Names of combatants attributed to these actions, per combineElementsToSummaryString.
 * @return html code as string
 */
function constructDialogInitiativeActionsContent(names = "") {
  names = combineElementsToSummaryString(names);

  const dialogInitiativeActionsContent = 
`
<h3> ${titleLabel} </h3> 
<p>${selectActionsParagraph}</p>
<p><em> ${names} </em></p>
<form>
  <table>
    <thead>
         <tr>
            <th style="text-align:left">${actionLabel}</th>
            <th colspan=2 style="text-align:right">${bonusActionLabel}</th>
         </tr>
      
         <tr>
           <td> </td>
           <td style="text-align:right"> <label for="None">${noneLabel}</label></td>
           <td> <input type="radio" name="BonusAction" id="BonusNone" class="ActionSelection" checked/></td>
         </tr>
      
         <tr>
           <td> <input type="checkbox" id="RangedAttack" class="ActionSelection"/></td>
           <td> <label for="RangedAttack">${rangedAttackLabel}</label></td>
           <td> <input type="radio" name="BonusAction" id="BonusRangedAttack" class="ActionSelection"/></td>
         </tr>
         
         <tr>
            <td> <input type="checkbox" id="Movement" class="ActionSelection"/></td>
            <td> <label for="Movement">${movementLabel}</label></td>
            <td> <input type="radio" name="BonusAction" id="BonusMovement"act class="ActionSelection"/></td>
         </tr>
    
         <tr>
            <td> <input type="checkbox" id="SwapGear" class="ActionSelection"/></td>
            <td> <label for="SwapGear">${swapGearLabel}</label></td>
            <td> <input type="radio" name="BonusAction" id="BonusSwapGear"act class="ActionSelection"/></td>
         </tr>
        
         <tr>
            <td> <input type="checkbox" id="OtherAction" class="ActionSelection"/></td>
            <td> <label for="OtherAction">${otherActionLabel}</label></td>
            <td> <input type="radio" name="BonusAction" id="BonusOtherAction"act class="ActionSelection"/></td>
         </tr>
      
         <tr>
            <td> <input type="checkbox" id="MeleeAttack" class="ActionSelection"/></td>
            <td> <label for="MeleeAttack">${meleeAttackLabel}</label></td>
            <td> <input type="radio" name="BonusAction" id="BonusMeleeAttack"act class="ActionSelection"/></td>
         </tr>
    
         <tr>
            <td> <input type="checkbox" id="CastSpell" class="ActionSelection"/></td>
            <td> <label for="CastSpell">${castSpellLabel}</label></td>
            <td> <input type="radio" name="BonusAction" id="BonusCastSpell"act class="ActionSelection"/></td>
         </tr>
      
         <tr>
           <td> <input type="checkbox" id="Other" class="ActionSelection"/> </td>
           <td colspan=2> <label for="Other">${otherLabel}</label> <input type="text" id="OtherText"/></td>
           
         </tr>
      

        
      </table> 
  

  
  <br><input type="checkbox" id="InitiativeBonus" class="ActionSelection"/>
  <label for="InitiativeBonus">${initiativeBonusLabel}</label>
  <input type="number" id="InitiativeBonusNumber" min=0 max=99 step=1 value=1>
 
  <br><input type="checkbox" id="InitiativePenalty" class="ActionSelection"/>
  <label for="InitiativePenalty">${initiativePenaltyLabel}</label>
  <input type="number" id="InitiativePenaltyNumber" min=0 max=99 step=1 value=1>  
  
  <br><input type="checkbox" id="Surprise" class="ActionSelection"/>
  <label for="Surprise">${surpriseLabel}</label>
  <input type="number" id="SupriseNumber" min=0 max=99 step=1 value=10>

  <br>
  
  <br><input type="radio" id="Normal" name="AdvDis" class="ActionSelection" Checked/>
  <label for="Normal">${normalLabel}</label> 
  <input type="radio" id="Advantage" name="AdvDis" class="ActionSelection"/>
  <label for="Advantage">${advantageLabel}</label> 
  <input type="radio" id="Disadvantage" name="AdvDis" class="ActionSelection"/>
  <label for="Disadvantage">disadvantageLabel</label> 
    
  <br>
    
  <br><input type="reset" id="resetButton" class="resetButton">
    </form>
    
  <p>
    <em>${selectActionsBonusParagraph}</em>
    <br><br>
    <em>${selectActionsAdvDisParagraph}</em> 
      
    <br><br>
    ${selectActionsMultipleParagraph}
  </p>
  
`
  return dialogInitiativeActionsContent;

}

/**
 * Create the dice command and associated action descriptions for the chosen actions.
 * @actionSelections One or more actions selected by the user in the action selection dialog.
 * @otherText Any text input by the user, which will be interpreted as dice commands.
 * @initBonus Initiative bonus chosen by user. Assumed to be 0 or more. Only used if Initiative Bonus was checked (in actionSelections).
 * @initPenalty Initiative penalty chosen by user. Assumed to be 0 or more. Only used if Initiative Penalty was checked (in actionSelections). 
 * @surprise Surprise penalty chosen by user. Only used if Surprise was checked (in actionSelections).
 * @return The die roll command for the initiative and the description string for the actions.
 */
function constructInitiativeRoll(actionSelections, otherText, initBonus = 1, initPenalty = 1, surprise = 10) {
  //console.log("actionSelections.Length: " + actionSelections.length);
  //console.log("actionSelections (0): " + actionSelections[0].id + " " + actionSelections[0].checked);
  //console.log("actionSelections (1): " + actionSelections[1].id + " " + actionSelections[1].checked);
  
  //console.log("Other text: " + otherText);
  //console.log("initBonus: " + initBonus);
  //console.log("initPenalty: " + initPenalty);
  //console.log("surprise: " + surprise);
  
  var actionPool = [];
  for(var i = 0; i < actionSelections.length; i++) {
    //console.log("\t selection id: " + actionSelections[i].id);
    //console.log("\t selection is checked: " + actionSelections[i].checked);
    if(actionSelections[i].checked) {
      //console.log("\tAdding " + actionSelections[i].id)
      actionPool.push(actionSelections[i].id);
    }
  }
  
  //console.log("actionPool: " + actionPool);
  
  let dice = calculateDice(actionPool, otherText, initBonus, initPenalty, surprise);
  let init_roll = constructInitiativeRollCommand(dice); 
  
  const action_str = TranslateActionPoolSelections(actionPool, otherText, initBonus, initPenalty, surprise);
  //console.log(action_str);
  
  return { init_roll, action_str };
}

/** 
 * Roll initiative for one or more ids given a particular die command.
 * @ids Combatant ids string array.
 * @init_roll String corresponding to the die roll command.
 * @actions HTML String corresponding to the actions to be noted in the chat message.
 * @return Nothing.
 */
async function doInitiative(ids, init_roll, actions = "") {
  //console.log("Rolling " + init_roll + " for " + ids);
  const message_options = {
    flavor: "Greyhawk Initiative Roll.<br>" + actions
  };
  
  await game.combat.rollInitiative(ids, init_roll, message_options);
  //console.log("Done " + id);
}

/**
 * Create a die roll command from dice.
 * @dice Array of DieRoll objects.
 * @return String corresponding to the die roll command (e.g. 2d4 + 2)
 */
function constructInitiativeRollCommand(dice) {
	var commandStringArray = [];
	dice.forEach( function(die) { 
		commandStringArray.push(die.printCommand());
	});

	let command_string = commandStringArray.join("");
	command_string = command_string.replace(/^[+]/, ""); // replace any starting "+"" 

	return command_string;
}

/**
 * Determine the various dice needed to accomplish the selected actions.
 * @actionPool One or more actions selected by the user in the action selection dialog.
 * @otherText Any text input by the user, which will be interpreted as dice commands.
 * @initBonus Initiative bonus chosen by user. Assumed to be 0 or more. Only used if Initiative Bonus was checked (in actionSelections).
 * @initPenalty Initiative penalty chosen by user. Assumed to be 0 or more. Only used if Initiative Penalty was checked (in actionSelections). 
 * @surprise Surprise penalty chosen by user. Only used if Surprise was checked (in actionSelections).
 * @return Array of DieRoll objects corresponding to the necessary die rolls required.
 */
function calculateDice(actionPool, other_text = "", initBonus = 1, initPenalty = 1, surprise = 10) {
	//console.log("CalculateDice");

	var die_strings = [];
	var initiative_bonus = false;
	var initiative_penalty = false;
	var advantage_type = "normal";
	actionPool.forEach( function(action) {
	  switch(action) {
		case 'RangedAttack':
		case 'BonusRangedAttack':  
		  die_strings.push(ACTION_DIE_SIDES.ranged_attack);
		  break;
	  
		case 'Movement':
		case 'BonusMovement': 
		  die_strings.push(ACTION_DIE_SIDES.movement);
		  break;
		   
		case 'SwapGear':
		case 'BonusSwapGear':
		  die_strings.push(ACTION_DIE_SIDES.swap_gear);
		  break;
		  
		case 'OtherAction':
		case 'BonusOtherAction':  
		  die_strings.push(ACTION_DIE_SIDES.other_action);
		  break;
	
		case 'MeleeAttack':
		case 'BonusMeleeAttack':  
		  die_strings.push(ACTION_DIE_SIDES.melee_attack);
		  break; 
	  
		case 'CastSpell':
		case 'BonusCastSpell':  
		  die_strings.push(ACTION_DIE_SIDES.spell);
		  break; 
	  
		case 'Other':     
		  die_strings.push( other_text );     
		  break;   
	  
		case 'Surprise':
		  surprise = parseInt( surprise );
		  die_strings.push( surprise );
		  break;
		case 'InitiativeBonus':
		  initiative_bonus = true;
		  initBonus = parseInt( initBonus );
		  break;
		case 'InitiativePenalty':
		  initiative_penalty = true;
		  initPenalty = parseInt( initPenalty );
		  break;   
	  
		case 'Advantage':
		  advantage_type = "advantage";
		  break;
		case 'Disadvantage':
		  advantage_type = "disadvantage";
		  break;
	
		default:
	  }
  
	}); 
   
	//console.log("\tDie strings: " + die_strings);
	var dice = createDiceArray(die_strings);

	if(initiative_bonus) {
	  // find the highest die; step side down by one increment (-2 sides) for each bonus
	  const largest_index = largestDie(dice);
	  //console.log("Applying +" + initBonus + " initiative bonus to die " + dice[largest_index].original_string);
  
	  for(var i=0; i < initBonus; i++) {
			dice[largest_index].decreaseSides();
	  }
	  //console.log("Resulting die sides: " + dice[largest_index].sides);
	}

	if(initiative_penalty) {
	  // find the smallest die; step side up by one increment (+2 sides) for each penalty
	  const smallest_index = smallestDie(dice);
	  //console.log("Applying -" + initPenalty + " initiative penalty to die " + dice[smallest_index].original_string);
	  
	  for(var i=0; i < initPenalty; i++) {
			dice[smallest_index].increaseSides();
	  }
	  //console.log("Resulting die sides: " + dice[smallest_index].sides);
	}

	if(advantage_type === "advantage") {
	  // find the highest die, roll with disadvantage in order to keep lowest
	  const largest_index = largestDie(dice);
	  dice[largest_index].disadvantage();
	}

	if(advantage_type == "disadvantage") {
	  // find the highest die, roll with advantage in order to keep highest
	  const largest_index = largestDie(dice);
	  dice[largest_index].advantage();
	}

	return dice;
}

/**
 * Describe the selected actions for use in the initiative roll chat message.
 * @actionPool One or more actions selected by the user in the action selection dialog.
 * @otherText Any text input by the user, which will be interpreted as dice commands.
 * @initBonus Initiative bonus chosen by user. Assumed to be 0 or more. Only used if Initiative Bonus was checked (in actionSelections).
 * @initPenalty Initiative penalty chosen by user. Assumed to be 0 or more. Only used if Initiative Penalty was checked (in actionSelections). 
 * @surprise Surprise penalty chosen by user. Only used if Surprise was checked (in actionSelections).
 * @return HTML string, as a bulleted list of actions.
 */
function TranslateActionPoolSelections(actionPool, other_text = "", initBonus = 1, initPenalty = 1, surprise = 10) {
  let str_array = [];

	actionPool.forEach( function(action) {
	   switch(action) {
		case 'RangedAttack':
		  str_array.push(`${rangedAttackChatLabel}`);
		  break;
		case 'BonusRangedAttack':  
		  str_array.push(`${bonusChatLabel}: ${rangedAttackChatLabel}`);
		  break;
		case 'Movement':
		  str_array.push(`${movementChatLabel}`);
		  break;
		case 'BonusMovement':  
		  str_array.push(`${bonusChatLabel}: ${movementChatLabel}`);
		  break;
		case 'SwapGear':
		  str_array.push(`${swapGearChatLabel}`);
		  break;
		case 'BonusSwapGear':
		  str_array.push(`${bonusChatLabel}: ${swapGearChatLabel}`);
		  break;
		case 'OtherAction':
		  str_array.push(`${otherActionChatLabel}`);
		  break;
	  case 'BonusOtherAction':
		  str_array.push(`${bonusChatLabel}: ${otherActionChatLabel}`);
		  break;    
		case 'MeleeAttack':
		  str_array.push(`${meleeAttackChatLabel}`);	
		  break;
		case 'BonusMeleeAttack':  
		  str_array.push(`${bonusChatLabel}: ${meleeAttackChatLabel}`);
		  break;
	  
		case 'CastSpell':
		  str_array.push(`${castSpellChatLabel}`);
		  break;
		case 'BonusCastSpell':  
		  str_array.push(`${bonusChatLabel}: ${castSpellChatLabel}`);
		  break; 
	  
		case 'Other':    
		  str_array.push(`${otherChatLabel}: ${other_text}`);
		  break;
	  
		case 'Surprise':
		  str_array.push(`${surpriseChatLabel} (+${surprise})`);
		  break;
		case 'InitiativeBonus':
		  str_array.push(`${initiativeBonusChatLabel} (+${initBonus})`);
		  break;
		case 'InitiativePenalty':
		  str_array.push(`${initiativePenaltyChatLabel} (-${initPenalty})`);
		  break;   
	  
		case 'Advantage':
		  str_array.push(`${advantageChatLabel}`);
		  break;
		case 'Disadvantage':
		  str_array.push(`${disadvantageChatLabel}`);
		  break;
	
		default:
	  }
	}); 
	  
	const str = "<ul><li>" + str_array.join("</li><li>") + "</ul>";  
	  
  return str;
	  
}
  
/**
 * Create array of DieRoll objects from an array of die command strings.
 * @diceStrings Array of dice commands as strings.
 * @return array of DieRoll objects.
 */  
function createDiceArray(diceStrings) {
  var dieStringArray = [];
  var dice = [];
  
  diceStrings.forEach( function(dieString, index) {
    if(!isBlank(dieString)) {
      const die_commands = splitDieCommand(dieString);
      die_commands.forEach( function(cmd, index) {
        dieStringArray.push(cmd); 
      });
    }
  });
  
  dieStringArray.forEach( function(dieString, index) {  
    dice.push(parseDieString(dieString));
  });
  
  return dice;
}

/**
 * Test for blank or empty string
 * @str String
 * @return True if object is blank ("") or empty.
 */  
function isBlank(str) {
    // https://stackoverflow.com/questions/154059/how-can-i-check-for-an-empty-undefined-null-string-in-javascript
    const is_blank = (!str || /^\s*$/.test(str));
    //console.log("isBlank? " + is_blank);
    return is_blank;
  }
  
/**
 * Parse a die string command. Only handles very basic rolls.
 * Looks for a "d". If none, assumes a number and treats like a d1. 
 * The digits before the "d" represent the number of dice; 
 * digits immediately after represent the number of sides;
 * everything else is a "remainder" added on at the end.
 * @die_string A string representing a die command.
 * @return A DieRoll object.
 */
function parseDieString(die_string) {
  // Die Rolls have number, side, remainder, and a modifier
  // e.g., 2d4, -3d6, 20d4 + 10  
  //console.log("parseDieString: " + die_string);
  
	if(isBlank(die_string)) {
		//console.log("\tDie is blank or null.");
		return die_string;
	}

	let res = die_string.toString().match(/^([+-])?(\d+)d(\d+)(.*)/i);
	if(null === res) {
		//console.log("\tDie pattern not matched. Trying integers.");
		res = die_string.toString().match(/^([+-])?(\d+)(.*)/i);
		if(null === res) {
			//console.log("\tDie pattern not matched.");
			return die_string;
		}
		// matched digits, like 10, or -20, or 10 + 1d6 + 2d4
	}
  
  //console.log("\tMatch results: " + res);
  //console.log("\tResults length: " + res.length);
  
  // 0: full string
  // 1: + or - (could be null)
  // 2: number
  // 3: sides or remainder if not a "d" pattern
  // 4: remainder for "d" pattern only
  if(4 == res.length) {
    // not "d" pattern
    let die_roll = new DieRoll(res[2],
                               1,
                               res[3],
                               res[1],
                               res[0]);
    
    return die_roll;
    
  } else if(5 === res.length) {
    // "d" pattern
    let die_roll = new DieRoll(res[2],
                               res[3],
                               res[4],
                               res[1],
                               res[0]);
    
    return die_roll;
  }
  
  //console.log("\tMatch returned unexpected result.");
  return die_string;
}

// --------------------------------------
// OBJECT: DIE ROLL
// --------------------------------------

/** 
 * Constructor for DieRoll.
 * @number Number of dice.
 * @sides Number of sides.
 * @remainder Rest of the die command, such as kl1 to keep the lowest die.
 * @modifier Either "+" or "-".
 * @original_str Original die string; only used for testing to track changes to the die roll.
 * @return a DieRoll object.
 */
function DieRoll(number, sides, remainder = "", modifier = "+", original_str = "") {
  this.number = parseInt( number );
  this.sides = parseInt( sides );
  this.remainder = remainder;
  this.modifier = modifier;
  this.original_string = original_str;
  
  this.advantage_type = "normal";
}
  
/**
 * DieRoll method to decrement the number of sides (typically by 2, so 1d6 --> 1d4).
 */  
DieRoll.prototype.decreaseSides = function() {
  console.log("decreaseSides");
  var self = this;
  console.log("Self sides: " + this.sides);
  this.sides = modifySides(self.sides, "decrease");
  console.log("Self sides: " + this.sides);
}

/**
 * DieRoll method to increment the number of sides (typically by 2, so 1d4 --> 1d6).
 */ 
DieRoll.prototype.increaseSides = function() {
  console.log("increaseSides");
  var self = this;
  console.log("Self sides: " + this.sides);
  this.sides = modifySides(self.sides, "increase");
  console.log("Self sides: " + this.sides);
}

/**
 * DieRoll method to apply advantage to the die.
 * Done by doubling the number of dice and keeping the highest group.
 * Increases the number of dice and adds the kh# command to the remainder.
 */
DieRoll.prototype.advantage = function() {
  if("advantage" === this.advantage_type) {
      return;
  }
   
  if("disadvantage" === this.advantage_type) {
    this.remainder = this.remainder.replace(/^kl\d+/, "");
    this.number = this.number / 2;
    this.advantage_type = "normal";
  }
    
  this.remainder = "kh" + this.number.toString();
  this.number = this.number * 2;  
  this.advantage_type = "advantage";
}

/**
 * DieRoll method to apply disadvantage to the die.
 * Done by doubling the number of dice and keeping the lowest group.
 * Increases the number of dice and adds the kl# command to the remainder.
 */
DieRoll.prototype.disadvantage = function() {
  if("disadvantage" === this.advantage_type) {
      return;
  }
   
  if("advantage" === this.advantage_type) {
    this.remainder = this.remainder.replace(/^kh\d+/, "");
    this.number = this.number / 2;
    this.advantage_type = "normal";
  }
    
  this.remainder = "kl" + this.number.toString();
  this.number = this.number * 2;  
  this.advantage_type = "disadvantage";
}

/**
 * DieRoll method to take away advantage/disadvantage to the die.
 * If necessary, decreases the number of dice and removes the kl# or kh# command from the remainder.
 */
DieRoll.prototype.normalize = function() {
  if("normal" === this.advantage_type) {
    return;
  }

  if("advantage" === this.advantage_type) {
    this.remainder = this.remainder.replace(/^kh\d+/, "");    
  }
  
  if("disadvantage" === this.advantage_type) {
    this.remainder = this.remainder.replace(/^kl\d+/, "");
  }
  
  this.number = ( this.number / 2 );
  this.advantage_type = "normal";
}

/**
 * DieRoll method to print the die roll command corresponding to the DieRoll object.
 */
DieRoll.prototype.printCommand = function() {
  let command_string = "";
  command_string = this.modifier + this.number.toString();
  
  if(1 == this.sides) {
    command_string += this.remainder;
  } else {
    command_string +=  "d" + this.sides.toString() + this.remainder;
  }
  
  return command_string;

}

/**
 * Used by increaseSides and decreaseSide DieRoll methods.
 * In most cases, increment or decrement the number of sides by 2.
 * If the die is 1, increase to 2.
 * If the die is 2, decrease to 1. 
 * Do not go below 1.
 * @current_sides Number of sides for the die.
 * @how "increase" or "decrease"
 * @return New number of sides.
 */
function modifySides(current_sides, how = "increase") {
  // increase or decrease by 2, as d4 through d12 use 2. 
  // for consistency, allow die in-between d12 and d20, and simply increase by 2 otherwise.
  //console.log("modifySides: " + current_sides);
  console.log("modifySides");
  current_sides = parseInt( current_sides );
  console.log("Current sides: " + current_sides);
  
  if("increase" === how) {
    if(current_sides <= 1) {
      return 2;
    }
  
    return current_sides + 2;
  } else if("decrease" == how) {
    if(current_sides <= 2) {
      return 1;
    }
    
    return current_sides - 2;
  }
  
  //console.log("modifySides: 'how' not recognized.");
  return current_sides;
 
}

/**
 * Find the highest or lowest number of die sides in an array of DieRoll objects.
 * Used by largestDie and smallestDie functions.
 * Ultimately needed to implement advantage/disadvantage and initiative bonus/penalty.
 * @dice DieRoll array
 * @type "max" or "min"
 * @return Corresponding index for the die in the array.
 */
function findDie(dice, type = "max") {
  var match_sides = null;
  var match_index;
  
  dice.forEach( function(die, index) {
    if(null == match_sides || ("max" == type && die.sides > match_sides) || ("min" == type && die.sides < match_sides)) {
      match_sides = die.sides;
      match_index = index;
    }
  });

  return match_index;
}

/**
 * Find the highest number of die sides in an array of DieRoll objects.
 * @dice DieRoll array
 * @return Corresponding index for the die in the array.
 */
function largestDie(dice) {
  //console.log("largestDie");
  const index = findDie(dice, "max");
  //console.log("Largest die: " + dice[index].die_str + " with " + dice[index].sides + " sides at index " + index);
  return index;  
}
  
/**
 * Find the smallest number of die sides in an array of DieRoll objects.
 * @dice DieRoll array
 * @return Corresponding index for the die in the array.
 */
function smallestDie(dice) {
  //console.log("largestDie");
  const index = findDie(dice, "min");
  //console.log("Largest die: " + dice[index].die_str + " with " + dice[index].sides + " sides at index " + index);
  return index;  
}

/**
 * Given a string of die roll commands, split by "+" or "-" into DieRoll objects.
 * @die_string String of commands, e.g. 1d6 + 2d4 + 20.
 * @return Array of DieRoll objects corresponding to each command.
 */
function splitDieCommand(die_string) {
	//console.log("splitDieCommand: " + die_string);
	if(isBlank(die_string)) {
		return null;
	}

  // check for combined commands, such as 1d6 + 2d4 + 20; split
  die_string = die_string.toString().replace(/ /g, "");
  die_string = die_string.split("+");
    
  if("" === die_string[0]) {
    die_string.shift();
  }
  
  var dieArray = [];
  
  die_string.forEach( function(die_str, index) {
    let minus_str = die_str.split("-");
    //console.log("\tminus_str: " + minus_str);
    
    let first_is_negative = false;
    
    if("" === minus_str[0]) {
      minus_str.shift();
      first_is_negative = true;
    }
    
    let die_to_add = minus_str.shift();
    if(first_is_negative) {
      die_to_add = "-" + die_to_add;
      
    } 
    dieArray.push(die_to_add);
    
    if(minus_str.length >  0) {
      // rest are negative
      minus_str.forEach( function(minus_s, index) {
        dieArray.push("-" + minus_s);
      });
    }   
  
  });
  
  return dieArray;
}

// --------------------------------------
// FUNCTIONS: INITIATIVE ACTIONS DIALOG
// --------------------------------------


// --------------------------------------
// MAIN CODE
// --------------------------------------

/**
 * First identify combatants owned by the user.
 * If multiple combatants, ask the user to select one or more.
 * Then ask the user to select actions for the chosen combatants.
 * Actions chosen apply to all combatants selected, but are rolled separately.
 * Finally, do the die rolls and update the initiative in the combat tracker.
 * @combatants One or more combatants from the combat tracker. 
 * @return Nothing.
 */
async function main(combatants) {
	let selected_combatants = filterSelectedCombatants(combatants);
	if(selected_combatants.length < 1) {
		//console.log("No selected combatants in combat.");
		// use combatants controlled by user instead
		selected_combatants = combatants;  
	}
	//console.log(selected_combatants.length + " combatants selected/owned.");


	let ids = [];
	if(selected_combatants.length == 1) {
		//console.log("Single combatant found.")
		ids = selected_combatants._id;
	} else if(selected_combatants.length < 1) {
	  console.log("No combatants found.");
	  return;
	
	} else {
		// list by PC / NPC. Groups: type, name. 
		const combatant_selection_html = constructCombatantSelectionHTML(combatants);
		//let PCSelection = [];
		//let CreatureSelection = [];
		// console.log(combatant_selection_html);
		
		let res = await dialogPromise(combatant_selection_html);
		//console.log(res);
		if("Cancel" === res) {
			//console.log("User cancelled.");
			return;
		} else if("Closed" == res) {
			//console.log("User closed");
			return;
		} else {
			const PCSelection = (res.find('[class=PCsSelection]'));
			const CreatureSelection = (res.find('[class=CreaturesSelection]'));
			ids = getSelectionIDs(PCSelection, CreatureSelection);
			selected_combatants = selected_combatants.filter(c => (ids.includes(c._id) ));
		}
	
	}

	// console.log(combatants[0]); 

	//console.log(ids);
	if(ids.length < 1) {
		console.log("No combatants selected.");
		return;
	}


	const combatant_names = selected_combatants.map(c => c.name);
	//console.log("Combatant names: " + combatant_names);

	const initiative_dialog_content = constructDialogInitiativeActionsContent(combatant_names);
	console.log(initiative_dialog_content);

	let res = await dialogPromise(initiative_dialog_content);


	let actionSelections = (res.find('[class=ActionSelection]'));
	if(actionSelections.length < 1) {
	  console.log("No actions selected.");
	  return;
	}
	
	let otherText = res.find('[id=OtherText]')[0].value;
	let initBonus = res.find('[id=InitiativeBonusNumber]')[0].value;
	let initPenalty = res.find('[id=InitiativePenaltyNumber]')[0].value;
	let surprise = res.find('[id=SupriseNumber]')[0].value;
	const { init_roll, action_str } = constructInitiativeRoll(actionSelections, otherText, initBonus, initPenalty, surprise);

	//console.log(action_str);


	//console.log("Rolling " + init_roll);
	doInitiative(ids, init_roll, action_str);
	//console.log("Done!");

}

// Preliminary checks 
// ------------------
let errorReason = '';
let combatants = game.combat.combatants;

if(combatants.length < 1) {
  errorReason = `${errorNoCombatants}`;
}

if(errorReason === '') {
  //console.log(combatants.length + " combatants total.");
	combatants = combatants.filter(c => c.owner);
	if(combatants.length < 1) {
	  errorReason = `${errorNoCombatantsOwned}`;
	}
}

// Main
// ----
if(errorReason === '') {
  //console.log(combatants.length + " combatants owned.");
  main(combatants);
 
} else {
  //console.log(`Error: ${errorReason}`);
  ui.notifications.error(`${errorReason}`);
}
